#include "def_utils.h"


#ifndef OPERATION
#error OPERATION not defined
#endif


static void __PASTE3(cvs_,OPERATION,_folder)(struct info_file* info_file, char *path, int path_offset) {

    char file_path[MAX_PATH_LENGTH];
    struct dirent *dp;
    DIR *dir = opendir(path);

    size_t len = strlen(path);
    path[len++] = '/';

    while ((dp = readdir(dir))) {

        if (!strcmp(dp->d_name,".") || !strcmp(dp->d_name,"..")) {

            continue;
        }

        strcpy(path + len, dp->d_name);

        if (is_directory(path)) {

            __PASTE3(cvs_,OPERATION,_folder)(info_file, path, path_offset);

            continue;
        }

        expand_path(file_path, "%s", path);

        __PASTE3(cvs_,OPERATION,_file)(info_file, file_path + path_offset, path);
    }

    closedir(dir);
}


int __PASTE2(cvs_,OPERATION)(int argc, char **argv) {

    struct cmd_tmp args = expand_arguments(argc, argv, false);
    struct info_file *info_file = read_client_file();

    for (int pos = 1; pos < argc; pos++) {

        if (is_directory(argv[pos])) {

            strcpy(args.argv[pos], argv[pos]);

            __PASTE3(cvs_,OPERATION,_folder)(info_file, args.argv[pos], args.path_offset);

        } else {

            __PASTE3(cvs_,OPERATION,_file)(info_file, args.argv[pos], argv[pos]);
        }
    }

    if (__PASTE3(cvs_,OPERATION,_file) == cvs_delete_file) {

        for (int pos = 1; pos < argc; pos++) {

            run_bash("rm -r %s", argv[pos]);
        }
    }

    write_client_file(info_file);
    free_info_file(info_file);
    free(args.argv);

    return 0;
}


#undef OPERATION

